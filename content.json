{"meta":{"title":"iosplayer","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-12-29T16:06:07.000Z","updated":"2019-12-29T16:06:29.428Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-12-29T15:55:34.000Z","updated":"2020-10-15T03:03:52.068Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"iOS多线程","slug":"4","date":"2021-03-12T08:03:51.000Z","updated":"2021-03-12T12:03:38.024Z","comments":true,"path":"2021/03/12/4/","link":"","permalink":"http://yoursite.com/2021/03/12/4/","excerpt":"一点点基础知识！","text":"一点点基础知识！ 多线程在之前我们提到，整个列表的数据都是从网络中请求加载到cell当中的，但是由于cell中含有图像的加载的问题，会造成我们App的启动速度十分缓慢和我们在滑动列表的时候产生严重的卡顿，所以接下来我们需要利用线程对列表的滑动体验进行优化。 优化前的效果 线程是什么线程是某一进程中一个单独运行的程序。也就是进程的一个实体，是CPU调度和分派的基本单位。 我们如何使用线程在iOS中，线程通常被分为主线程和其他线程。通常我们编写的代码都是在主线程中运行的。为了优化体验，我们需要将图片的加载过程放入到其他线程中，并且在Cell中使用占位图，在非主线程中请求图片数据并加载到Cell上。 12345678910let downloadImageThread = Thread(block: &#123; [self] in do &#123; rightImage.image = UIImage(data: try Data(contentsOf: URL(string: model.thumbnail_pic_s)!)) &#125; catch &#123; &#125; &#125;) downloadImageThread.name = &quot;downloadImageThread&quot; downloadImageThread.start() 在写下以上代码之后，可以发现无论是App的启动速度和列表的滑动体验都又了明显的提升。 效果如下 但是我们可以在Xcode中看见系统进行了警告 虽然我们提前放置了占位图，但是任何有关UI的操作都应该放在主线程中进行 所以我们在这里引入另外一个线程的管理方式 Grand Central Dispatch（GCD）在了解GCD之前，我们需要在这里引入两个概念，任务和队列 任务：指的是我们需要执行的操作，也就是代码块（block）中的代码。 队列：指的是执行任务的等待队列，从数据结构中我们知道队列的特点是先进先出，所以我们的任务也是先进先出的。 GCD的优点就是，使开发者从面向线程较为底层的管理变成了面向队列，由系统来为队列从线程池中分配线程执行我们的任务。 将上述代码改成使用GCD的方式则如下所示 1234567891011121314151617//全局并发队列let downloadQueue = DispatchQueue.global(qos: .default) let mainQueue = DispatchQueue.main //在非主队列中进行网络请求 downloadQueue.async(execute: &#123; [self] in var modelImage: UIImage? = nil do &#123; modelImage = UIImage(data: try Data(contentsOf: URL(string: model.thumbnail_pic_s)!)) &#125; catch &#123; &#125; //在主队列中进行UI操作 mainQueue.async(execute: &#123; [self] in rightImage.image = modelImage &#125;) &#125;) 最终效果","categories":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"沙盒和列表数据缓存","slug":"3","date":"2021-03-09T13:00:54.000Z","updated":"2021-03-10T09:32:58.534Z","comments":true,"path":"2021/03/09/3/","link":"","permalink":"http://yoursite.com/2021/03/09/3/","excerpt":"继续！","text":"继续！ 沙盒沙盒是什么沙盒：是iOS中每一个应用的独立储存空间。每个应用都只能访问自己沙盒中的文件，无法相互通信。当应用需要请求或接受沙盒外的数据时，都需要经过权限认证，否则无法获取到数据。 沙盒路径以及文件类型在模拟器运行环境下得到的沙盒根路径（每次编译运行都会得到新的沙盒路径，当使用真机运行时则不会生成新的沙盒） 123let homePath = NSHomeDirectory() print(homePath)///Users/wangtao/Library/Developer/CoreSimulator/Devices/FBE21BF5-1A14-4730-8BD1-2E62809CBAD2/data/Containers/Data/Application/007C7152-B54A-419C-8779-C9445B2C67EF 以及沙盒中所包含的文件 沙盒文件夹的作用Documents保存持久化的数据，例如用户的登录信息、搜索记录等一些关键数据。系统会为存储在这个文件夹下的数据进行备份 LibraryLibrary中包含Caches和Preferences两个文件夹 Caches:用于存储缓存数据，且不会被系统备份 Preferences:用于保存持久化数据，NSUserDefaults就存放在此文件夹中，会被系统备份 SystemData新加入到沙盒中的文件，具体作用未知 tmp用于存放临时数据，应用退出时会清除该目录下的数据，且不会被系统备份。 列表数据缓存在理解了沙盒的机制之后，我们将通过沙盒来缓存我们加载到cell的列表数据，以便用户在第二次打开时优先展示本地数据而不是空cell。 数据归档我们需要将网络请求的数据实时储存到沙盒中进行保存。在这里我们将数据写入Lilbrary/Cache/Data/list中 使用NSSearchPathForDirectoriesInDomains获取沙盒路径 在沙盒中创建文件夹路径 使用FileManager创建目录和文件 讲对象（这里是类型数组）序列化成Data 将Data写入文件 在此我们引入一个概念序列化 1自定义对象是无法写入到文件的，必须转换成二进制流的格式。从对象到二进制数据的过程我们称为序列化，将二进制数据还原成对象的过程，我们称为反序列化。iOS中对象序列化需要实现NSCoding类协议，实现序列化与反序列化方法。 在此我们通过NSScureCoding实现序列化以及反序列化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class NewsModel: NSObject, NSSecureCoding &#123; public static var supportsSecureCoding: Bool = true // Coder 转 Obj public required init?(coder: NSCoder) &#123; author_name = coder.decodeObject(forKey: &quot;author_name&quot;) as! String category = coder.decodeObject(forKey: &quot;category&quot;) as! String date = coder.decodeObject(forKey: &quot;date&quot;) as! String thumbnail_pic_s = coder.decodeObject(forKey: &quot;thumbnail_pic_s&quot;) as! String title = coder.decodeObject(forKey: &quot;title&quot;) as! String uniquekey = coder.decodeObject(forKey: &quot;uniquekey&quot;) as! String url = coder.decodeObject(forKey: &quot;url&quot;) as! String &#125; public var author_name: String public var category: String public var date: String public var thumbnail_pic_s: String public var title: String public var uniquekey: String public var url: String init(author_name: String, category: String, date: String, thumbnail_pic_s: String, title: String, uniquekey: String, url: String) &#123; self.author_name = author_name self.category = category self.date = date self.thumbnail_pic_s = thumbnail_pic_s self.title = title self.uniquekey = uniquekey self.url = url &#125; // Obj 转 Coder public func encode(with coder: NSCoder) &#123; coder.encode(author_name, forKey: &quot;author_name&quot;) coder.encode(category, forKey: &quot;category&quot;) coder.encode(date, forKey: &quot;date&quot;) coder.encode(thumbnail_pic_s, forKey: &quot;thumbnail_pic_s&quot;) coder.encode(title, forKey: &quot;title&quot;) coder.encode(uniquekey, forKey: &quot;uniquekey&quot;) coder.encode(url, forKey: &quot;url&quot;) &#125;&#125; 在实现完Model的协议方法之后，我们将对象序列化成二进制数据 123456789101112131415161718private func archiveData(data: [NewsModel]) &#123; let cacheArray = NSSearchPathForDirectoriesInDomains(.cachesDirectory, .userDomainMask, true) if let cachePath = cacheArray.first &#123; let fileManager = FileManager.default let dataPath = cachePath.appending(&quot;/Data/&quot;) do &#123; try fileManager.createDirectory(atPath: dataPath, withIntermediateDirectories: true, attributes: nil) let listDataPath = dataPath.appending(&quot;list&quot;) do &#123; // Obj 转 Data let listData = try NSKeyedArchiver.archivedData(withRootObject: data, requiringSecureCoding: true) fileManager.createFile(atPath: listDataPath, contents: listData, attributes: nil) &#125; &#125; catch &#123; print(&quot;error&quot;) &#125; &#125; &#125; 当我们网络请求成功后，我们应该重写本地数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344public func loadNetWork(block: @escaping ((Bool, Array&lt;NewsModel&gt;) -&gt; Void)) &#123; // 本地数据加载优先于网络加载 if let localData = loadDataFromLocal() &#123; block(true, localData) &#125; // 网络加载 let urlString = &quot;http://v.juhe.cn/toutiao/index?type=top&amp;key=1113811726e766953e642681e1371677&quot; let url = URL(string: urlString)! let session = URLSession.shared let task = session.dataTask(with: url) &#123; [self] data, _, error in guard error == nil else &#123; fatalError(&quot;Task Error&quot;) &#125; guard let jsonData = data else &#123; fatalError(&quot;Data Error&quot;) &#125; do &#123; // Data 转 JSON guard let dic = try JSONSerialization.jsonObject(with: jsonData, options: .allowFragments) as? [String: Any] else &#123; fatalError(&quot;JSONSerialization Error&quot;) &#125; guard let resultDic = dic[&quot;result&quot;] as? [String: Any] else &#123; fatalError(&quot;JSONSerialization Error&quot;) &#125; guard let dataArray = resultDic[&quot;data&quot;] as? [Any] else &#123; fatalError(&quot;JSONSerialization Error&quot;) &#125; var modelArray = [NewsModel]() for item in dataArray &#123; let dic = item as! [String: String] let model = NewsModel(author_name: dic[&quot;author_name&quot;]!, category: dic[&quot;category&quot;]!, date: dic[&quot;date&quot;]!, thumbnail_pic_s: dic[&quot;thumbnail_pic_s&quot;]!, title: dic[&quot;title&quot;]!, uniquekey: dic[&quot;uniquekey&quot;]!, url: dic[&quot;url&quot;]!) modelArray.append(model) &#125; archiveData(data: modelArray) // 主线程刷新 DispatchQueue.main.async &#123; block(true, modelArray) &#125; &#125; catch &#123; // error &#125; &#125; task.resume() &#125; 反归档将本地文件反序列化为对象数组 12345678910111213141516171819private func loadDataFromLocal() -&gt; [NewsModel]? &#123; let homePath = NSHomeDirectory() print(homePath) let cacheArray = NSSearchPathForDirectoriesInDomains(.cachesDirectory, .userDomainMask, true) if let cachePath = cacheArray.first &#123; // 创建文件管理器 let fileManager = FileManager.default // 文件路径 let listDataPath = cachePath.appending(&quot;/Data/list&quot;) // 文件数据加载为Data if let readListData = fileManager.contents(atPath: listDataPath) &#123; // Data 转 Obj if let listDataArray = try? NSKeyedUnarchiver.unarchivedObject(ofClasses: [NewsModel.self, NSArray.self], from: readListData) as? [NewsModel] &#123; return listDataArray &#125; &#125; &#125; return nil &#125; 当我们开始网络请求之前应该先从本地读取数据加载到cell，优化用户体验 12345678public func loadNetWork(block: @escaping ((Bool, Array&lt;NewsModel&gt;) -&gt; Void)) &#123; // 本地数据加载优先于网络加载 if let localData = loadDataFromLocal() &#123; block(true, localData) &#125; //网络请求 .... &#125; 最终效果","categories":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"请求网络json数据并加载到TableViewCell","slug":"2","date":"2020-11-27T13:07:07.000Z","updated":"2020-11-28T06:19:13.009Z","comments":true,"path":"2020/11/27/2/","link":"","permalink":"http://yoursite.com/2020/11/27/2/","excerpt":"学习不止！","text":"学习不止！ swift写法网络请求与数据处理网络请求利用URL和URLSession.dataTask完成我们的api请求 123456let urlString = \"http://v.juhe.cn/toutiao/index\" let url = URL(string: urlString)! let session = URLSession.shared let task = session.dataTask(with: url) &#123; (data, response, error) in &#125; json数据的处理 首先我们需要知道，从网络上请求回来的数据是返回dataTask的data，并且其中还带着一些请求所返回的参数，于是我们接着在dataTaks中将请求回来的数据转换为json数据，然后再利用字典逐步提取其中的我们所需要的数据。 12345678910111213141516171819guard error == nil else &#123; fatalError(\"Task Error\") &#125; guard let jsonData = data else &#123; fatalError(\"Data Error\") &#125; do &#123; // Data 转 JSON guard let dic = try JSONSerialization.jsonObject(with: jsonData, options: .allowFragments) as? [String : Any] else &#123; fatalError(\"JSONSerialization Error\") &#125; //提取JSON中的result guard let resultDic = dic[\"result\"] as? [String : Any] else &#123; fatalError(\"JSONSerialization Error\") &#125; //提取result中的data guard let dataArray = resultDic[\"data\"] as? [Any] else &#123; fatalError(\"JSONSerialization Error\") &#125; 由于这只是个人的开发，所以对于错误和数据为空的处理较为简单。接着我们将提取出来的字典数据，转化为model，并且。 model应该创建于一个独立的文件当中 123456789101112import Foundationimport UIKitpublic struct NewsModel &#123; public var author_name: String public var category: String public var date: String public var thumbnail_pic_s: String public var title: String public var uniquekey: String public var url: String&#125; 转化过程的代码应该也在dataTask中 12345var modelArray = [NewsModel]() for item in dataArray &#123; let dic = item as! [String: String] let model = NewsModel(author_name: dic[\"author_name\"]!, category: dic[\"category\"]!, date: dic[\"date\"]!, thumbnail_pic_s: dic[\"thumbnail_pic_s\"]!, title: dic[\"title\"]!, uniquekey: dic[\"uniquekey\"]!, url: dic[\"url\"]!) modelArray.append(model) 到此我们已经完成了第一步，网络请求和数据处理。接下来就是讲数据传递到cell中并加载数据。 数据加载到cell加载的顺序graph LR 视图控制器创建网络请求并在子线程中执行 --> 网络请求获取数据并传入视图控制器 网络请求获取数据并传入视图控制器 --> 主线程重加载cell的数据 数据的传递首先我们需要在网络请求的方法中传入一个闭包用于传递数据，并且由于需要将数据的刷新加载至主线程中所以闭包必须是逃逸闭包 1234567public func loadNetWork(block: @escaping ((Bool, Array&lt;NewsModel&gt;) -&gt; Void)) &#123; ... ... DispatchQueue.main.async &#123; block(true, modelArray) &#125;&#125; 同时我们在cell中也要创建一个传递数据的方法 1234567891011public func modelForCell(model: NewsModel) &#123; titleLabel.text &#x3D; model.title sourceLabel.text &#x3D; model.category commentLabel.text &#x3D; model.author_name timeLabel.text &#x3D; model.date do &#123; rightImage.image &#x3D; UIImage(data: try Data(contentsOf: URL(string: model.thumbnail_pic_s)!)) &#125; catch &#123; &#125; &#125; 在控制器中，我们需要创建网络请求，并且在cell的注册方法中调用modelForCell(model: NewsModel) 1234567891011121314override func viewDidLoad() &#123; super.viewDidLoad() view.addSubview(newsTableView) let loader &#x3D; ListLoder() loader.loadNetWork &#123; (success, model) in self.data &#x3D; model self.newsTableView.reloadData() &#125; &#x2F;&#x2F;extnsion func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell &#x3D; tableView.dequeueReusableCell(withIdentifier: &quot;reusedcell&quot;) as! NewsTableViewCell cell.modelForCell(model: data[indexPath.row]) return cell &#125; 到此，我们就已经完成了整个数据从网络请求到加载到cell当中，由于我个人的实力问题，部分代码还无法进行很好的解释，在后续的学习当中我会更新讲解 附上最后的效果 附上我的仓库地址","categories":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"}]}]}