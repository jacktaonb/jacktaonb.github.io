{"meta":{"title":"iosplayer","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-12-29T16:06:07.000Z","updated":"2019-12-29T16:06:29.428Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-12-29T15:55:34.000Z","updated":"2020-10-15T03:03:52.068Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"请求网络json数据并加载到TableViewCell","slug":"2","date":"2020-11-27T13:07:07.000Z","updated":"2020-11-28T06:19:13.009Z","comments":true,"path":"2020/11/27/2/","link":"","permalink":"http://yoursite.com/2020/11/27/2/","excerpt":"学习不止！","text":"学习不止！ swift写法网络请求与数据处理网络请求利用URL和URLSession.dataTask完成我们的api请求 123456let urlString = \"http://v.juhe.cn/toutiao/index\" let url = URL(string: urlString)! let session = URLSession.shared let task = session.dataTask(with: url) &#123; (data, response, error) in &#125; json数据的处理 首先我们需要知道，从网络上请求回来的数据是返回dataTask的data，并且其中还带着一些请求所返回的参数，于是我们接着在dataTaks中将请求回来的数据转换为json数据，然后再利用字典逐步提取其中的我们所需要的数据。 12345678910111213141516171819guard error == nil else &#123; fatalError(\"Task Error\") &#125; guard let jsonData = data else &#123; fatalError(\"Data Error\") &#125; do &#123; // Data 转 JSON guard let dic = try JSONSerialization.jsonObject(with: jsonData, options: .allowFragments) as? [String : Any] else &#123; fatalError(\"JSONSerialization Error\") &#125; //提取JSON中的result guard let resultDic = dic[\"result\"] as? [String : Any] else &#123; fatalError(\"JSONSerialization Error\") &#125; //提取result中的data guard let dataArray = resultDic[\"data\"] as? [Any] else &#123; fatalError(\"JSONSerialization Error\") &#125; 由于这只是个人的开发，所以对于错误和数据为空的处理较为简单。接着我们将提取出来的字典数据，转化为model，并且。 model应该创建于一个独立的文件当中 123456789101112import Foundationimport UIKitpublic struct NewsModel &#123; public var author_name: String public var category: String public var date: String public var thumbnail_pic_s: String public var title: String public var uniquekey: String public var url: String&#125; 转化过程的代码应该也在dataTask中 12345var modelArray = [NewsModel]() for item in dataArray &#123; let dic = item as! [String: String] let model = NewsModel(author_name: dic[\"author_name\"]!, category: dic[\"category\"]!, date: dic[\"date\"]!, thumbnail_pic_s: dic[\"thumbnail_pic_s\"]!, title: dic[\"title\"]!, uniquekey: dic[\"uniquekey\"]!, url: dic[\"url\"]!) modelArray.append(model) 到此我们已经完成了第一步，网络请求和数据处理。接下来就是讲数据传递到cell中并加载数据。 数据加载到cell加载的顺序graph LR 视图控制器创建网络请求并在子线程中执行 --> 网络请求获取数据并传入视图控制器 网络请求获取数据并传入视图控制器 --> 主线程重加载cell的数据 数据的传递首先我们需要在网络请求的方法中传入一个闭包用于传递数据，并且由于需要将数据的刷新加载至主线程中所以闭包必须是逃逸闭包 1234567public func loadNetWork(block: @escaping ((Bool, Array&lt;NewsModel&gt;) -&gt; Void)) &#123; ... ... DispatchQueue.main.async &#123; block(true, modelArray) &#125;&#125; 同时我们在cell中也要创建一个传递数据的方法 1234567891011public func modelForCell(model: NewsModel) &#123; titleLabel.text &#x3D; model.title sourceLabel.text &#x3D; model.category commentLabel.text &#x3D; model.author_name timeLabel.text &#x3D; model.date do &#123; rightImage.image &#x3D; UIImage(data: try Data(contentsOf: URL(string: model.thumbnail_pic_s)!)) &#125; catch &#123; &#125; &#125; 在控制器中，我们需要创建网络请求，并且在cell的注册方法中调用modelForCell(model: NewsModel) 1234567891011121314override func viewDidLoad() &#123; super.viewDidLoad() view.addSubview(newsTableView) let loader &#x3D; ListLoder() loader.loadNetWork &#123; (success, model) in self.data &#x3D; model self.newsTableView.reloadData() &#125; &#x2F;&#x2F;extnsion func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell &#x3D; tableView.dequeueReusableCell(withIdentifier: &quot;reusedcell&quot;) as! NewsTableViewCell cell.modelForCell(model: data[indexPath.row]) return cell &#125; 到此，我们就已经完成了整个数据从网络请求到加载到cell当中，由于我个人的实力问题，部分代码还无法进行很好的解释，在后续的学习当中我会更新讲解 附上最后的效果 附上我的仓库地址","categories":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"第一个垃圾项目的总结","slug":"1","date":"2020-09-13T13:20:07.000Z","updated":"2020-10-15T03:06:20.185Z","comments":true,"path":"2020/09/13/1/","link":"","permalink":"http://yoursite.com/2020/09/13/1/","excerpt":"轮子才是最好的工具和学习方法！","text":"轮子才是最好的工具和学习方法！ 在开始做考核项目之前，我只学会常用的UI控件的使用，并且只能进行简单的使用，对于dalegate和datesource的使用几乎为0。 学了部分课程之后也只学会了部分控件的扩展，对于一些控件也没有进行实际操作过。个人感觉，如果你只是单纯通过书本或者视频又或是通过他人的代码而不是去亲手实践这些控件，你无法在你需要用到的时候快速的写出来，每次要用到的时候还需要去查询各种资料进行借鉴才能使用出来。这也是我的这个总结的由来，通过每一次实践中遇到的坑的总结，帮助自己填平以后学习的路。 第一个问题：TableViewcell无法拉到屏幕底部这个问题主要是由于当cell的数量超出屏幕底部的时候，TableView的height属性也应该相应的减小 如下代码所示 let tableView = UITableView(frame: CGRect(x: 0, y: 0, width: frame.width, height: frame.height - 50)) cell无法显示到tapbar的底部 当将代码改成 let tableView = UITableView(frame: CGRect(x: 0, y: 0, width: frame.width, height: frame.height - 145)) cell就可以完全的显示了。 由于这次项目只是显示固定个数的cell，所以是使用的具体的数值来调试的，当使用个数不定的cell的时候，需要将height和cell的个数进行相关联避免出现此类的bug。 针对每个cell或者每个部位的navigationController当使用多个cell时，大部分需要应该是每个cell会推进到不同的页面，所以在需要在 (func tableView( _ tableView: UITableView, didSelectRowAt indexPath: IndexPath))针对每一个cell的indexPath.row使用控制流进行推进，但是我觉得应该在大量cell的时候会用更加简洁的方法而不是使用简单的控制流进行推进。同时也附上我的复杂代码 (func tableView( _ tableView: UITableView, didSelectRowAt indexPath: IndexPath) { if(indexPath.row == 0){ let detailVC = webViewController1() navigationController?.pushViewController(detailVC, animated: true) } else if(indexPath.row == 1){ let detailVC=webViewController2() navigationController?.pushViewController(detailVC, animated: true) })在下一次项目总结的时候，我会寻找到更加合适的方法来写次推进方法 仍然未解决的问题只使用一个viewcontroller来实现不同cell的访问网页的需求 下一阶段的目标 学习DNSPageVIew和BWDView框架并尽可能的重写一个简化版的框架出来 学习（界面传值代理闭包通知）、数据储存、架构模式 继续学习课程，并完成一个完成的新闻类App。 寻找这个总结中所提到的更好的方案。","categories":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"}]}]}