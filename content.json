{"meta":{"title":"iosplayer","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-12-29T16:06:07.000Z","updated":"2019-12-29T16:06:29.428Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-12-29T15:55:34.000Z","updated":"2020-10-15T03:03:52.068Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"沙盒和列表数据缓存","slug":"3","date":"2021-03-09T13:00:54.000Z","updated":"2021-03-10T09:32:58.534Z","comments":true,"path":"2021/03/09/3/","link":"","permalink":"http://yoursite.com/2021/03/09/3/","excerpt":"继续！","text":"继续！ 沙盒沙盒是什么沙盒：是iOS中每一个应用的独立储存空间。每个应用都只能访问自己沙盒中的文件，无法相互通信。当应用需要请求或接受沙盒外的数据时，都需要经过权限认证，否则无法获取到数据。 沙盒路径以及文件类型在模拟器运行环境下得到的沙盒根路径（每次编译运行都会得到新的沙盒路径，当使用真机运行时则不会生成新的沙盒） 123let homePath = NSHomeDirectory() print(homePath)///Users/wangtao/Library/Developer/CoreSimulator/Devices/FBE21BF5-1A14-4730-8BD1-2E62809CBAD2/data/Containers/Data/Application/007C7152-B54A-419C-8779-C9445B2C67EF 以及沙盒中所包含的文件 沙盒文件夹的作用Documents保存持久化的数据，例如用户的登录信息、搜索记录等一些关键数据。系统会为存储在这个文件夹下的数据进行备份 LibraryLibrary中包含Caches和Preferences两个文件夹 Caches:用于存储缓存数据，且不会被系统备份 Preferences:用于保存持久化数据，NSUserDefaults就存放在此文件夹中，会被系统备份 SystemData新加入到沙盒中的文件，具体作用未知 tmp用于存放临时数据，应用退出时会清除该目录下的数据，且不会被系统备份。 列表数据缓存在理解了沙盒的机制之后，我们将通过沙盒来缓存我们加载到cell的列表数据，以便用户在第二次打开时优先展示本地数据而不是空cell。 数据归档我们需要将网络请求的数据实时储存到沙盒中进行保存。在这里我们将数据写入Lilbrary/Cache/Data/list中 使用NSSearchPathForDirectoriesInDomains获取沙盒路径 在沙盒中创建文件夹路径 使用FileManager创建目录和文件 讲对象（这里是类型数组）序列化成Data 将Data写入文件 在此我们引入一个概念序列化 1自定义对象是无法写入到文件的，必须转换成二进制流的格式。从对象到二进制数据的过程我们称为序列化，将二进制数据还原成对象的过程，我们称为反序列化。iOS中对象序列化需要实现NSCoding类协议，实现序列化与反序列化方法。 在此我们通过NSScureCoding实现序列化以及反序列化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class NewsModel: NSObject, NSSecureCoding &#123; public static var supportsSecureCoding: Bool = true // Coder 转 Obj public required init?(coder: NSCoder) &#123; author_name = coder.decodeObject(forKey: &quot;author_name&quot;) as! String category = coder.decodeObject(forKey: &quot;category&quot;) as! String date = coder.decodeObject(forKey: &quot;date&quot;) as! String thumbnail_pic_s = coder.decodeObject(forKey: &quot;thumbnail_pic_s&quot;) as! String title = coder.decodeObject(forKey: &quot;title&quot;) as! String uniquekey = coder.decodeObject(forKey: &quot;uniquekey&quot;) as! String url = coder.decodeObject(forKey: &quot;url&quot;) as! String &#125; public var author_name: String public var category: String public var date: String public var thumbnail_pic_s: String public var title: String public var uniquekey: String public var url: String init(author_name: String, category: String, date: String, thumbnail_pic_s: String, title: String, uniquekey: String, url: String) &#123; self.author_name = author_name self.category = category self.date = date self.thumbnail_pic_s = thumbnail_pic_s self.title = title self.uniquekey = uniquekey self.url = url &#125; // Obj 转 Coder public func encode(with coder: NSCoder) &#123; coder.encode(author_name, forKey: &quot;author_name&quot;) coder.encode(category, forKey: &quot;category&quot;) coder.encode(date, forKey: &quot;date&quot;) coder.encode(thumbnail_pic_s, forKey: &quot;thumbnail_pic_s&quot;) coder.encode(title, forKey: &quot;title&quot;) coder.encode(uniquekey, forKey: &quot;uniquekey&quot;) coder.encode(url, forKey: &quot;url&quot;) &#125;&#125; 在实现完Model的协议方法之后，我们将对象序列化成二进制数据 123456789101112131415161718private func archiveData(data: [NewsModel]) &#123; let cacheArray = NSSearchPathForDirectoriesInDomains(.cachesDirectory, .userDomainMask, true) if let cachePath = cacheArray.first &#123; let fileManager = FileManager.default let dataPath = cachePath.appending(&quot;/Data/&quot;) do &#123; try fileManager.createDirectory(atPath: dataPath, withIntermediateDirectories: true, attributes: nil) let listDataPath = dataPath.appending(&quot;list&quot;) do &#123; // Obj 转 Data let listData = try NSKeyedArchiver.archivedData(withRootObject: data, requiringSecureCoding: true) fileManager.createFile(atPath: listDataPath, contents: listData, attributes: nil) &#125; &#125; catch &#123; print(&quot;error&quot;) &#125; &#125; &#125; 当我们网络请求成功后，我们应该重写本地数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344public func loadNetWork(block: @escaping ((Bool, Array&lt;NewsModel&gt;) -&gt; Void)) &#123; // 本地数据加载优先于网络加载 if let localData = loadDataFromLocal() &#123; block(true, localData) &#125; // 网络加载 let urlString = &quot;http://v.juhe.cn/toutiao/index?type=top&amp;key=1113811726e766953e642681e1371677&quot; let url = URL(string: urlString)! let session = URLSession.shared let task = session.dataTask(with: url) &#123; [self] data, _, error in guard error == nil else &#123; fatalError(&quot;Task Error&quot;) &#125; guard let jsonData = data else &#123; fatalError(&quot;Data Error&quot;) &#125; do &#123; // Data 转 JSON guard let dic = try JSONSerialization.jsonObject(with: jsonData, options: .allowFragments) as? [String: Any] else &#123; fatalError(&quot;JSONSerialization Error&quot;) &#125; guard let resultDic = dic[&quot;result&quot;] as? [String: Any] else &#123; fatalError(&quot;JSONSerialization Error&quot;) &#125; guard let dataArray = resultDic[&quot;data&quot;] as? [Any] else &#123; fatalError(&quot;JSONSerialization Error&quot;) &#125; var modelArray = [NewsModel]() for item in dataArray &#123; let dic = item as! [String: String] let model = NewsModel(author_name: dic[&quot;author_name&quot;]!, category: dic[&quot;category&quot;]!, date: dic[&quot;date&quot;]!, thumbnail_pic_s: dic[&quot;thumbnail_pic_s&quot;]!, title: dic[&quot;title&quot;]!, uniquekey: dic[&quot;uniquekey&quot;]!, url: dic[&quot;url&quot;]!) modelArray.append(model) &#125; archiveData(data: modelArray) // 主线程刷新 DispatchQueue.main.async &#123; block(true, modelArray) &#125; &#125; catch &#123; // error &#125; &#125; task.resume() &#125; 反归档将本地文件反序列化为对象数组 12345678910111213141516171819private func loadDataFromLocal() -&gt; [NewsModel]? &#123; let homePath = NSHomeDirectory() print(homePath) let cacheArray = NSSearchPathForDirectoriesInDomains(.cachesDirectory, .userDomainMask, true) if let cachePath = cacheArray.first &#123; // 创建文件管理器 let fileManager = FileManager.default // 文件路径 let listDataPath = cachePath.appending(&quot;/Data/list&quot;) // 文件数据加载为Data if let readListData = fileManager.contents(atPath: listDataPath) &#123; // Data 转 Obj if let listDataArray = try? NSKeyedUnarchiver.unarchivedObject(ofClasses: [NewsModel.self, NSArray.self], from: readListData) as? [NewsModel] &#123; return listDataArray &#125; &#125; &#125; return nil &#125; 当我们开始网络请求之前应该先从本地读取数据加载到cell，优化用户体验 12345678public func loadNetWork(block: @escaping ((Bool, Array&lt;NewsModel&gt;) -&gt; Void)) &#123; // 本地数据加载优先于网络加载 if let localData = loadDataFromLocal() &#123; block(true, localData) &#125; //网络请求 .... &#125; 最终效果","categories":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"请求网络json数据并加载到TableViewCell","slug":"2","date":"2020-11-27T13:07:07.000Z","updated":"2020-11-28T06:19:13.009Z","comments":true,"path":"2020/11/27/2/","link":"","permalink":"http://yoursite.com/2020/11/27/2/","excerpt":"学习不止！","text":"学习不止！ swift写法网络请求与数据处理网络请求利用URL和URLSession.dataTask完成我们的api请求 123456let urlString = \"http://v.juhe.cn/toutiao/index\" let url = URL(string: urlString)! let session = URLSession.shared let task = session.dataTask(with: url) &#123; (data, response, error) in &#125; json数据的处理 首先我们需要知道，从网络上请求回来的数据是返回dataTask的data，并且其中还带着一些请求所返回的参数，于是我们接着在dataTaks中将请求回来的数据转换为json数据，然后再利用字典逐步提取其中的我们所需要的数据。 12345678910111213141516171819guard error == nil else &#123; fatalError(\"Task Error\") &#125; guard let jsonData = data else &#123; fatalError(\"Data Error\") &#125; do &#123; // Data 转 JSON guard let dic = try JSONSerialization.jsonObject(with: jsonData, options: .allowFragments) as? [String : Any] else &#123; fatalError(\"JSONSerialization Error\") &#125; //提取JSON中的result guard let resultDic = dic[\"result\"] as? [String : Any] else &#123; fatalError(\"JSONSerialization Error\") &#125; //提取result中的data guard let dataArray = resultDic[\"data\"] as? [Any] else &#123; fatalError(\"JSONSerialization Error\") &#125; 由于这只是个人的开发，所以对于错误和数据为空的处理较为简单。接着我们将提取出来的字典数据，转化为model，并且。 model应该创建于一个独立的文件当中 123456789101112import Foundationimport UIKitpublic struct NewsModel &#123; public var author_name: String public var category: String public var date: String public var thumbnail_pic_s: String public var title: String public var uniquekey: String public var url: String&#125; 转化过程的代码应该也在dataTask中 12345var modelArray = [NewsModel]() for item in dataArray &#123; let dic = item as! [String: String] let model = NewsModel(author_name: dic[\"author_name\"]!, category: dic[\"category\"]!, date: dic[\"date\"]!, thumbnail_pic_s: dic[\"thumbnail_pic_s\"]!, title: dic[\"title\"]!, uniquekey: dic[\"uniquekey\"]!, url: dic[\"url\"]!) modelArray.append(model) 到此我们已经完成了第一步，网络请求和数据处理。接下来就是讲数据传递到cell中并加载数据。 数据加载到cell加载的顺序graph LR 视图控制器创建网络请求并在子线程中执行 --> 网络请求获取数据并传入视图控制器 网络请求获取数据并传入视图控制器 --> 主线程重加载cell的数据 数据的传递首先我们需要在网络请求的方法中传入一个闭包用于传递数据，并且由于需要将数据的刷新加载至主线程中所以闭包必须是逃逸闭包 1234567public func loadNetWork(block: @escaping ((Bool, Array&lt;NewsModel&gt;) -&gt; Void)) &#123; ... ... DispatchQueue.main.async &#123; block(true, modelArray) &#125;&#125; 同时我们在cell中也要创建一个传递数据的方法 1234567891011public func modelForCell(model: NewsModel) &#123; titleLabel.text &#x3D; model.title sourceLabel.text &#x3D; model.category commentLabel.text &#x3D; model.author_name timeLabel.text &#x3D; model.date do &#123; rightImage.image &#x3D; UIImage(data: try Data(contentsOf: URL(string: model.thumbnail_pic_s)!)) &#125; catch &#123; &#125; &#125; 在控制器中，我们需要创建网络请求，并且在cell的注册方法中调用modelForCell(model: NewsModel) 1234567891011121314override func viewDidLoad() &#123; super.viewDidLoad() view.addSubview(newsTableView) let loader &#x3D; ListLoder() loader.loadNetWork &#123; (success, model) in self.data &#x3D; model self.newsTableView.reloadData() &#125; &#x2F;&#x2F;extnsion func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell &#x3D; tableView.dequeueReusableCell(withIdentifier: &quot;reusedcell&quot;) as! NewsTableViewCell cell.modelForCell(model: data[indexPath.row]) return cell &#125; 到此，我们就已经完成了整个数据从网络请求到加载到cell当中，由于我个人的实力问题，部分代码还无法进行很好的解释，在后续的学习当中我会更新讲解 附上最后的效果 附上我的仓库地址","categories":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"第一个垃圾项目的总结","slug":"1","date":"2020-09-13T13:20:07.000Z","updated":"2020-10-15T03:06:20.185Z","comments":true,"path":"2020/09/13/1/","link":"","permalink":"http://yoursite.com/2020/09/13/1/","excerpt":"轮子才是最好的工具和学习方法！","text":"轮子才是最好的工具和学习方法！ 在开始做考核项目之前，我只学会常用的UI控件的使用，并且只能进行简单的使用，对于dalegate和datesource的使用几乎为0。 学了部分课程之后也只学会了部分控件的扩展，对于一些控件也没有进行实际操作过。个人感觉，如果你只是单纯通过书本或者视频又或是通过他人的代码而不是去亲手实践这些控件，你无法在你需要用到的时候快速的写出来，每次要用到的时候还需要去查询各种资料进行借鉴才能使用出来。这也是我的这个总结的由来，通过每一次实践中遇到的坑的总结，帮助自己填平以后学习的路。 第一个问题：TableViewcell无法拉到屏幕底部这个问题主要是由于当cell的数量超出屏幕底部的时候，TableView的height属性也应该相应的减小 如下代码所示 let tableView = UITableView(frame: CGRect(x: 0, y: 0, width: frame.width, height: frame.height - 50)) cell无法显示到tapbar的底部 当将代码改成 let tableView = UITableView(frame: CGRect(x: 0, y: 0, width: frame.width, height: frame.height - 145)) cell就可以完全的显示了。 由于这次项目只是显示固定个数的cell，所以是使用的具体的数值来调试的，当使用个数不定的cell的时候，需要将height和cell的个数进行相关联避免出现此类的bug。 针对每个cell或者每个部位的navigationController当使用多个cell时，大部分需要应该是每个cell会推进到不同的页面，所以在需要在 (func tableView( _ tableView: UITableView, didSelectRowAt indexPath: IndexPath))针对每一个cell的indexPath.row使用控制流进行推进，但是我觉得应该在大量cell的时候会用更加简洁的方法而不是使用简单的控制流进行推进。同时也附上我的复杂代码 (func tableView( _ tableView: UITableView, didSelectRowAt indexPath: IndexPath) { if(indexPath.row == 0){ let detailVC = webViewController1() navigationController?.pushViewController(detailVC, animated: true) } else if(indexPath.row == 1){ let detailVC=webViewController2() navigationController?.pushViewController(detailVC, animated: true) })在下一次项目总结的时候，我会寻找到更加合适的方法来写次推进方法 仍然未解决的问题只使用一个viewcontroller来实现不同cell的访问网页的需求 下一阶段的目标 学习DNSPageVIew和BWDView框架并尽可能的重写一个简化版的框架出来 学习（界面传值代理闭包通知）、数据储存、架构模式 继续学习课程，并完成一个完成的新闻类App。 寻找这个总结中所提到的更好的方案。","categories":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"}]}]}